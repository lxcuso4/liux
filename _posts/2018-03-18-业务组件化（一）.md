---
layout: post
title: 前端业务组件化的思考
categories: frame
description: 业务功能组件化。
keywords: vue，组件化， js
---


### 前端业务组件分享

#### 为什么要业务组件化

+ 一套代码多业务线，多端使用
+ 一次修改全部生效
+ 灵活的组件组织方式

#### 如何业务组件化

+ 使用框架 Vue、 Vuex、 Vue-Router
+ 按照一定规范和方式开发组件
+ 不论是在单页或者多页中使用按照同样的方式实例化业务组件

#### 组件化需要解决的问题

1. 全局变量冲突（组件内部的全局状态和业务实例全局状态）
2. 全局路由冲突（组件内部路由和业务实例路由）
3. 不同场景、业务线，logo、文案、样式不同（静态依赖）
4. 状态依赖（运行时依赖）
   - router跳转的时候
   - 全局vuex 依赖
5. 初始化动作
   - 初始化时候需要执行的额外动作
6. 完成后状态导出
   - postinstall
   - 全局mutation
7. 完成后动作

#### 组件化架构方式

1. 使用vuex module 隔离组件全局状态和业务实例全局状态
2. 顶级路由命名需要保证其命名空间，不能起通用路由名称
3. 静态依赖通过在业务实例化的时候传入congfig，组件内部需要在有区别的地方,做判断
4. 实例化业务组件的时候，组件依赖通过router跳转的时候加参数传递给组件组件在内部接收；
业务公共base_info也可以直接vuex依赖顶层业务状态，组件自述需要声明
5. 组件初始化后需要执行的动作，通过在congfig中传入startinstall在组件初始化的时候执行
6. 完成后状态导出
   -  通过在congfig中传入postinstall在组件功能完成后执行，this绑定到组件实例，组件完成后结果作为参数postinstall参数；
   -  全流程的大项目中也可以通过提交全局mutation，更新全局依赖

7. 通过在congfig中传入postinstall在组件功能完成后执行

#### 组件对外提供接口

1. 对外提供一个或多个route选项对象
2. 对外提供一个store选项对象

路由：业务实例化的时候通过引入组件route然后和自有route拼装后实例化来引入组件

store：通过引入组件store然后合并到业务modules然后实例化引入组件store


#### 一些问题

>  目前组件都在compont仓库，所以业务引用的时候，业务引用A组件的老版本，B组件更新了，业务因为要更新B导致A也引用到最新的了

+  不同业务组件用一个独立的仓库，业务在引用的时候可以保证其引用版本不变
